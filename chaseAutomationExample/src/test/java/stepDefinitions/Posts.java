package stepDefinitions;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import dto.Post;
import io.cucumber.java.en.Given;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import io.restassured.response.Response;
import org.junit.Assert;
import utils.EndPoints;
import utils.RestExchange;
import utils.TestContext;
import java.util.HashMap;
import java.util.List;


public class Posts {
    private TestContext testContext;
    RestExchange restExchange;


    public Posts(TestContext testContext) {
        this.testContext = testContext;
    }

    @Given("I create a post with {string} and {string} for {string} with response code {int}")
    public void iCreateAPostWithAndForWithResponseCode(String title, String body, String userId, int statusCode) throws JsonProcessingException {
        //creating the json Body
        Response response = createPost(title, body, userId, statusCode);
        System.out.println("The response body is - > ");
        response.prettyPrint();
        Assert.assertEquals(response.statusCode(), statusCode);
        //map response to Post class
        if (response.statusCode() == 201) {
            mapResponsetoPostClass(response);
        }
    }

    @Then("The new post is posted against the {string} with {string} and {string}")
    public void theNewPostIsPostedAgainstTheWithAnd(String userId, String title, String body) {

        /*  to be implemented.
          As the actual resource is not getting created by the API,
          we cannot test if the post has actually been created for the user
          however, we have saved the post Id that is created in the text context, so we can search via
         the api below and check if the title, body and user Id match
         https://jsonplaceholder.typicode.com/posts/ {post id}
         */
    }

    @When("I update the post with {string} and {string} for {string} with response code {int}")
    public void iUpdateThePostWithAndForWithResponseCode(String title, String body, String userId, int statusCode) throws JsonProcessingException {
        Post post = createFakePost(title, body, userId);
        HashMap<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        String endpoint = testContext.BASE_URL + EndPoints.PATCH_posts.replace("{postId}", "1");
        /*
        replacing the post id with a hard coded value as the postID is not generated by the system
         */
        Response response = restExchange.patchWithHeader(headers, endpoint, mapObjectAsJson(post));
        response.prettyPrint();
        Assert.assertEquals(response.statusCode(), statusCode);

    }

    @Then("the post is updated for the {string} with {string} and {string}")
    public void thePostIsUpdatedForTheWithAnd(String user, String title, String body) {
        /*  to be implemented.
          As the actual resource is not getting created by the API,
          we cannot test if the post has actually been updated for the user
          however, we have saved the post Id that is created in the text context, so we can search via
         the api below and check if the title, body and user Id match
         https://jsonplaceholder.typicode.com/posts/ {post id}
         */
    }

    @When("I delete the post with {int}")
    public void iDeleteThePostWith(int statusCode) {
        String endpoint = testContext.BASE_URL + EndPoints.PATCH_posts.replace("{postId}", "1");
        /*
        replacing the post id with a hard coded value as the postID is not generated by the system
         */
        Response response = restExchange.deleteResource(endpoint);
        response.prettyPrint();
        Assert.assertEquals(response.statusCode(), statusCode);
    }

    @Then("the search result for the post returns {int}")
    public void theSearchResultForThePostReturns(int statusCode) {
         /*  to be implemented.
          As the actual resource is not getting created by the API,
          we cannot test if the post has actually been updated for the user
          however, we have saved the post Id that is created in the text context, so we can search via
         the api below and check if the title, body and user Id match
         https://jsonplaceholder.typicode.com/posts/ {post id}
         */
    }

    @When("I search for all posts for a {string} with response code {int}")
    public void iSearchForAllPostsForAWithResponseCode(String user, int statusCode) {
        String endpoint = testContext.BASE_URL + EndPoints.GET_posts
                .replace("{userId}", user);
        testContext.response = restExchange.getResponse(endpoint);
        Assert.assertEquals(testContext.response.statusCode(), statusCode);
    }

    @Then("all the records are of the {string}")
    public void allTheRecordsAreOfThe(String user) {
        testContext.response.prettyPrint();
        List<Integer> userIDs = testContext.response.jsonPath().getList("userId");
        for (Integer currentuser : userIDs) {
            Assert.assertTrue(Integer.parseInt(user) == currentuser);
        }
    }

    @Then("the response is empty")
    public void theResponseIsEmpty() {
        List<String> posts = testContext.response.jsonPath().getList("$");
        Assert.assertTrue(posts.isEmpty());
    }

    @When("I create a post with {string} and {string} with response code {int}")
    public void iCreateAPostWithAndWithResponseCode(String title, String body, int statusCode) throws JsonProcessingException {

        List<Integer> userIDs = testContext.response.jsonPath().getList("id");
        for (Integer currentuser : userIDs) {
            testContext.response = createPost(title, body, currentuser.toString(), statusCode);
            System.out.println("The response body is - > ");
            testContext.response.prettyPrint();
            Assert.assertEquals(testContext.response.statusCode(), statusCode);
        }
    }

    private void mapResponsetoPostClass(Response response) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        // Pass JSON string and the POJO class
        Post postResponse = objectMapper.readValue(response.asString(), Post.class);
        testContext.postId = postResponse.getId();
    }

    private Response createPost(String title, String body, String userId, int statusCode) {
        Post post = createFakePost(title, body, userId);
        HashMap<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        String endpoint = testContext.BASE_URL + EndPoints.POST_posts;
        // fetch response
        return restExchange.postWithHeader(headers, endpoint, mapObjectAsJson(post));
        //print response

    }

    private String mapObjectAsJson(Post post) {
        String postJson = null;
        ObjectMapper mapper = new ObjectMapper();
        try {
            postJson = mapper.writeValueAsString(post);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return postJson;
    }

    private Post createFakePost(String title, String body, String userId) {
        Post post = new Post();
        post.setTitle(title);
        post.setBody(body);
        post.setUserId(Integer.valueOf(userId));
        return post;
    }
}
