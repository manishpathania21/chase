package stepDefinitions;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import dto.Comment;
import io.cucumber.java.en.Then;
import io.cucumber.java.en.When;
import io.restassured.response.Response;
import org.junit.Assert;
import utils.EndPoints;
import utils.RestExchange;
import utils.TestContext;

import java.util.HashMap;

public class Comments {
    private TestContext testContext;
    RestExchange restExchange;

    public Comments(TestContext testContext) {
        this.testContext = testContext;
    }
    @When("I create a comment with {string} and {string} and {string} with {int}")
    public void iCreateACommentWithAndAndWith(String name, String email, String body,Integer statusCode) throws JsonProcessingException {
        //Create a comment
        Response response = createAComment(name,email,body);
        //print response
        System.out.println("The response body is - > ");
        response.prettyPrint();
        Assert.assertTrue(response.statusCode() == statusCode);
        //map response to class
        if (response.statusCode() == 201) {
           mapResponseToCommentClass(response);
        }
    }


    @When("I update the comment with {string} and {string} and {string} with {int}")
    public void iUpdateTheCommentWithAndAndWith(String name, String email, String body,Integer statusCode) {
        //Create a comment
        Comment comment = createFakeComment(name,email,body);
        HashMap<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        String endpoint = testContext.BASE_URL + EndPoints.PATCH_Comments.replace("{commentId}","1");
        /* hardcoding the value of comment Id as the resource is not getting generated
         */
        // fetch response
        Response response = restExchange.patchWithHeader(headers, endpoint, mapObjectAsJson(comment));
        //print response
        System.out.println("The response body is - > ");
        response.prettyPrint();
        Assert.assertTrue(response.statusCode() == statusCode);

    }

    @Then("I can search for the comment with {string} and {string} and {string} with {int}")
    public void iCanSearchForTheCommentWithAndAndWith(String name, String email, String body,Integer statusCode) {

        /*  to be implemented.
          As the actual resource is not getting created by the API,
          we cannot test if the comment has actually been created for the user
          however, we have saved the comment Id that is created in the text context, so we can search via
         the api below and check if the name, email and body match
         https://jsonplaceholder.typicode.com/comments/{commentId}
         */
    }


    @When("I delete a comment with {int}")
    public void iDeleteACommentWith(int statusCode) {
        String endpoint = testContext.BASE_URL + EndPoints.PATCH_Comments.replace("{commentId}","1");
        /*
        replacing the post id with a hard coded value as the commentId is not generated by the system
         */
        Response response = restExchange.deleteResource(endpoint);
        response.prettyPrint();
        Assert.assertEquals(response.statusCode(), statusCode);
    }

    @Then("the search result for the comment returns {int}")
    public void theSearchResultForTheCommentReturns(int statusCode) {

        /*  to be implemented.
          As the actual resource is not getting created by the API,
          we cannot test if the post has actually been updated for the user
          however, we have saved the comment Id that is created in the text context
         */
    }

    private void mapResponseToCommentClass(Response response) throws JsonProcessingException {
        ObjectMapper objectMapper = new ObjectMapper();
        // Pass JSON string and the POJO class
        Comment commentResponse = objectMapper.readValue(response.asString(), Comment.class);
        testContext.commentId = commentResponse.getId();
    }

    private Response createAComment(String name, String email, String body) {
        Comment comment = createFakeComment(name,email,body);
        HashMap<String, String> headers = new HashMap<>();
        headers.put("Content-Type", "application/json");
        String endpoint = testContext.BASE_URL + EndPoints.POST_Comments.replace("{postId}","1");
        /*
        hardcoding the value of post Id as the resource is not getting generated
         */

        // fetch response
        return restExchange.postWithHeader(headers, endpoint, mapObjectAsJson(comment));
    }

    private Comment createFakeComment(String name, String email, String body) {
        Comment comment = new Comment();
        comment.setName(name);
        comment.setEmail(email);
        comment.setBody(body);
        return  comment;
    }
    private String mapObjectAsJson( Comment comment) {
        String postJson = null;
        ObjectMapper mapper = new ObjectMapper();
        try {
            postJson = mapper.writeValueAsString(comment);
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
        return postJson;
    }
}